<!DOCTYPE html>
<html>
<head>
</head>
<body>
<p><span style="text-decoration: underline;"><strong>Assignment 1 - Building a Three Dimensional Maze</strong> </span><br /></p>
<p>We are going to recreate the Rogue game in three dimensions.<br />Each assignment in the course will add more features to the game. <br />This assignment focusses on creating the maze and some objects<br />in the world, as well as adding collision detection and gravity<br />for the player.</p>
<p>A description of Rogue is available here:<br /><a href="https://en.wikipedia.org/wiki/Rogue_(video_game)">https://en.wikipedia.org/wiki/Rogue_(video_game)</a></p>
<p>You can play Rogue in a web browser at:<br /><a href="https://www.myabandonware.com/game/rogue-4n/play-4n">https://www.myabandonware.com/game/rogue-4n/play-4n</a></p>
<p>A description of the Rogue-like games is available here:<br /><a href="https://en.wikipedia.org/wiki/Roguelike">https://en.wikipedia.org/wiki/Roguelike</a></p>
<p></p>
<p><strong>1. World Building</strong><br /><br />Create a three dimensional maze from cubes.</p>
<p>The mazes in Rogue consist of several rooms attached by corridors. The<br />algorithm to create the maze involves randomly creating the rooms and then<br />attaching them to each other using the corridors. The rooms are organized<br />in a 3x3 grid.</p>
<p>1. Create nine randomly positioned rooms. The rooms should have randomized<br />depths and widths.<br />2. Randomly position doors on the room walls. You will need one door for each<br />corridor to another room. It makes sense to place the doors on the walls<br />facing other rooms. Do not align the doors so there is always a straight<br />path between them.<br />3. Attach the rooms to each other by building corridors between the doors.</p>
<p>The maze must be randomly generated. Each time the program is run it should<br />produce a different maze. The maze should consist of nine rooms with<br />three rooms per row, with three rows.</p>
<p>The rooms can all be rectangular or square. You can experiment<br />with other shapes for rooms is you wish.</p>
<p>Corridors are created using the doorways between two rooms as the starting<br />and ending positions. If the doors are not directly facing each other then<br />you will need to create a bend in the corridor so it can attach between<br />the two doors. The easiest way to do this is likely to pick a space between<br />the two doorways and create a perpendicular corridor to join the two doorways.</p>
<p>For example, if these are the edges of two rooms and the d is the doorway.</p>
<pre>             XXX<br />XXX          X<br />  d          X<br />  X          X<br />  X          X<br />XXX          X<br />             d<br />             XXX</pre>
<p>Each corridor will move away from the door in a line.</p>
<pre><br />             XXX<br />XXX          X<br />  d......    X<br />  X          X<br />  X          X<br />XXX          X<br />      .......d<br />             XXX<br /><br /></pre>
<p>Pick a random perpendicular corridor to join these two corridors.</p>
<pre><br />             XXX<br />XXX          X<br />  d......    X<br />  X     .    X<br />  X     .    X<br />XXX     .    X<br />        .....d<br />             XXX<br /><br /></pre>
<p>You should calculate the locations for the perpendicular corridor before <br />any corridors are created.</p>
<p>There must be enough space between each room to allow a corridor to<br />pass between them. This means that rooms cannot be created with only one<br />row of blocks between them.</p>
<p>Make the rooms and the corridors at least two units tall. This will be<br />necessary to test gravity.</p>
<p>Make the walls of the maze a different colour to the floor so they<br />are clearly visible. You can create custom colours for the cubes using<br />setUserColours() if you wish. Don't choose colours that make the maze<br />difficult for the TA to see (such as making the walls, floor, and ceiling<br />all the same colour).</p>
<p>Create a pattern in the ground using two different colours. For example, the<br />floor could be primarily dark brown with some lighter brown squares<br />which contrast the other areas. This can be done by changing the colour<br />at different randomized locations or by creating a pattern on the floor.</p>
<p>Position the maze near the middle of the world array (somewhere around 25 in<br />the y axis of world[x][y][z]). We may add multi-layer mazes with higher or lower<br />level in the future so there will need to be space in the world array<br />above and below the current level.</p>
<p>Place some randomly positioned cubes on the ground in the rooms. These should<br />be single cubes. There do not need to be a lot of these cubes. They will<br />be used to test the gravity and collision detection parts of the assignment.<br />If the viewpoint moves off of the top of one of these cubes then gravity<br />should cause it to fall to the ground. The user should not be able to move<br />to a position where they can see inside of these cubes or any other cubes<br />in the game.</p>
<p>As the entire game world is on a two dimensional plane it might be useful<br />to create a two dimensional array which represents the positions for rooms,<br />doors, and corridors. This might be helpful when you are creating the corridors<br />between rooms. Once the two dimensional array is complete you can use it to<br />create the 3D game world. This isn't required but it can be easier to<br />organize the world in 2D then build the 3D version using the 2D as a guide.</p>
<p>You can organize the world space in a 3x3 grid so the rooms cannot overlap but<br />the dimensions and the position of the rooms must be randomized. A room may be<br />constrained to appear within a space in the grid but it should not always start<br />in the same place or have the same size. Room sizes should range from small<br />to large.</p>
<p></p>
<p><strong>2. Collision Detection</strong></p>
<p>Add collision detection so the viewpoint cannot pass into a space<br />which is occupied by a cube. Any world space that is not set equal to 0<br />is occupied.</p>
<p>Test for collisions by checking if the position the viewpoint will move<br />into is an occupied space in the world. Write the collision detection so<br />that the viewpoint does not pass inside a cube at any time.</p>
<p>An exception to this allows the player to climb on top of a cube. This<br />occurs when the viewpoint would pass into a cube that is occupied but<br />when there is nothing above that cube. In this case the viewpoint will<br />move on top of the existing cube. This lets the player climb on top of<br />something that is one cube tall. If there were two cubes<br />stacked on top of each other then the player would not automatically<br />climb on top of them and they would collide with the cubes normally (and<br />stop moving).</p>
<p>The simplest method for collision detection is to test if the next move<br />of the viewpoint will enter an occupied cube. If the cube is occupied<br />then prevent the movement. This can be done using the get and set viewposition<br />functions.</p>
<p>Responding to a collision when it is just about to occur<br />may not always be sufficient. It is possible in some cases<br />for the viewpoint to pass into the edge of a cube and not register as<br />being inside the cube. This allows the user to see inside the cube<br />when they should not be able to do so. You may need to take into consideration<br />the direction which the viewpoint is moving and predict when it is getting<br />near to the cube instead of it being inside the cube. In this case you<br />are actually looking for the viewpoint being close to an occupied space<br />instead of inside that space.</p>
<p>Add collision detection so the viewpoint cannot move outside the<br />space defined by the world array. The viewpoint should not move to<br />a position less than 0 in any direction. It should not move to a position<br />greater than 99 in the x and z direction, and not greater than 49 in the y<br />direction.</p>
<p>You can use the functions:</p>
<p>getViewPosition()<br />setViewPosition()<br />getOldtViewPosition()<br />setOldViewPosition()</p>
<p>to prevent the viewpoint from entering an occupied cube. You will need to<br />test that the next viewpoint position will not be inside a space which is<br />occupied in the world[][][] array (it cannot be equal to anything other than 0).<br />If the next viewpoint position is occupied then you will need to set the<br />new position to an older position which was not occupied.</p>
<p>A tricky part of the assignment will be preventing the viewpoint from<br />entering the edge of a cube. It is fairly easy to stop the viewpoint from<br />passing through a cube but it is more difficult to stop it from peeking<br />inside the edge of a cube. It is not impossible but it may take some<br />experimentation with when controlling the viewpoint.</p>
<p></p>
<p><strong>3. Gravity</strong><br /><br />Add gravity to the program so the viewpoint descends to the ground.<br />The rate of descent should not be too fast (e.g. 0.1 per update). <br />Note that because the indices are negative, gravity is an increase in y.</p>
<p>Gravity operates like a collision with the ground. If gravity would<br />push the viewpoint into an occupied cube then it should not be be allowed<br />to move the viewpoint.</p>
<p>The user should not have to press f for gravity to take effect at the<br />start of the game. It should be in effect once the game starts.</p>
<p>4. A Few Things to Think About<br />------------------------------<br />Timing of events will be added in a later assignment. This will require the<br />update() function to be modified so that events occur on a times schedule<br />and are not dependent on the speed of the processor. You don't need to<br />include this with assignment 1 but you can consider it when modifying the<br />update() function. Events will eventually timed to they occur on a schedule<br />and not every time the update() function is called.</p>
<p>This may not be a problem you encounter with this assignment but if you<br />are having problems with the old and new positions not being the<br />same when there is no keypress then you need to think about how the positions<br />are updated by the system. The system responds to two types of events. Either<br />the player presses a key (a keyboard() event) or it operates when nothing else<br />is happening (the update() function). The keyboard function will set the old<br />and new view positions to be correct after a keypress. The update function<br />doesn't automatically update the old position so it will never change. If no<br />key is pressed then the position variables aren't updated and they contain the<br />movement values from the last time a key was pressed. It is up to you to make<br />sure the position variables are modified in update.</p>
<p></p>
<p><strong>Viewpoint Motion</strong><br />By default the system moves in the direction of the w, a, s, or d key<br />when pressed. When one of these keys is not being pressed then the<br />motion stops.</p>
<p><strong>Choosing Parameters</strong><br />It is important to pick values for parameters such as colours, speed of<br />objects, the effect of gravity so they are easy for the marker to see.<br />If the effect of a parameter it isn't obvious or is difficult to<br />see then it will be marked as missing or incomplete.</p>
<p>Make sure colours are distinct. Choose velocities for moving objects<br />that are fast enough to be seen.</p>
<p><strong>Coding Practices</strong><br />Write the code using standard stylistic practices. Use functions, <br />reasonable variable names, and consistent indentation.<br />If the code is difficult for the TA to understand then you<br />will lose marks.</p>
<p>As usual, keep backups of your work using source control software.</p>
<p><strong>Starting Code</strong><br />The starting code is available on the Courselink site.<br />You can untar the file using tar xf filename.<br />All of the changes to the code can be made in the a1.c file.</p>
<p>Note that the graphics code may be modified for assignment 2. If you<br />make changes to the graphics code (in graphics.c or visible.c) then you<br />may have to recode the changes in assignment 2.</p>

</body>
</html>